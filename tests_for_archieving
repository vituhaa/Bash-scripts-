#!/bin/bash


# 1: Создание виртуального диска.
VIRTUAL_DISK="$HOME/virtual_disk.img"
MOUNT_POINT="$HOME/mount_point"
# переменная VIRTUAL_DISK содрежит путь к виртуальному диску, который будет создан в домашней директории пользователя с именем virtual_disk.img
# переменная MOUNT_POINT содержит путь к точке монтирования. это будет директория, в которую монтируется виртуальный диск.
# виртуальный диск - программная эмуляция физического диска (жесткого диска, SSD, CD/DVD и т.д.), который существует в виде файла на реальном устройстве,
# например, на жёстком диске.
# точка монтирования - это каталог в файловой системе, к которому присоединяется содержимое раздела, устройства или удалённого ресурса, чтобы ОС и пользователи
# могли получить доступ к данным на этом устройстве.


dd if=/dev/zero of="$VIRTUAL_DISK" bs=1M count=1024
# команда dd - для копирования данных.
# if=/dev/zero - источник данных, это специальное устройство, которое выдаёт нули.

# if= — это параметр, который указывает на входной файл. В данном случае if=/dev/zero указывает, что команда dd будет читать данные из виртуального файла 
# /dev/zero, а не из обычного файла или устройства.

# /dev/zero — это виртуальный файл в Unix/Linux, который генерирует бесконечный поток нулевых байтов (0x00). Это специальное устройство используется для
# различных задач, где нужно заполнить область памяти или устройства нулевыми байтами.

# of="$VIRTUAL_DISK"  - файл,куда записываются данные (наш виртуальный диск)
# of= — это параметр, который указывает на выходной файл (то есть, куда будут записаны данные). Данные, прочитанные из /dev/zero, можно записывать в файл, 
# раздел или физический диск.
# Таким образом, команда dd if=/dev/zero of="$DISK" bs=1M count=1024 используется для записи 1 ГБ нулевых байтов на устройство или файл.
# bs=1M  - размер блока, равный 1Мб
# count=1024  - количество блоков, которое будет записано, что создаст файл размером 1Гб (1024 Мб)



mkfs.ext4 "$VIRTUAL_DISK"
# эта команда создаёт файловую систему ext4 на виртуальном диске
# mkfs - утилита (вспомогательная комп. программа) для создания файловой системы.
# ext4 - тип файловой системы, который поддерживает большие файлы и разделы.
# "$VIRTUAL_DISK" - переменная, содержащая путь к устройству или разделу, который будет отформатирован (например /dev/sdb, /dev/sda1).


mkdir -p "$MOUNT_POINT"
# создаёт директорию для точки монтирования, если она ещё не существует. флаг -p позволяет избежать ошибки, если директория уже есть.



sudo mount -o loop "$VIRTUAL_DISK" "$MOUNT_POINT"
# монтирует виртуальный диск в указанную точку монтирования.
# -o loop  - используется при монтировании файла, чтобы система воспринимала этот файл как устройство и могла с ним работать так, как если бы это был 
# реальный физический диск.
# "$VIRTUAL_DISK"  - путь к вирутальному диску.
# "$MOUNT_POINT"  - директория, в которую диск будет смонтирован.



sudo chmod -R 777 "$MOUNT_POINT"
# меняет права доступа на дисректорию монтирования и всё её содержимое на полные права для всех пользователей:
# chmod - используется для иземенения прав доступа к файлам и каталогам.
# -R  - рекурсия. означает, что команда будет применяться не только к самой директории, но и к файлам внутри.
# 777 - права чтения, записи и исполнения для всех (владельца, группы и остальных).



mkdir -p "$MOUNT_POINT/log"
# создаёт папку log на новом разделе, которая будет использоваться для хранения файлов журнала. 
# опция -p предотвращает  ошибку, если папка уже существует.



mkdir -p "$HOME/backup"
# создаёт папку backup в домашней директории пользователя, где будут храниться архивы.



echo "Виртуальный диск смонтирован в $MOUNT_POINT. Папка 'log' создана."




function generate_files()  # функция принимает два аргумента:
{
    local files_counter=$1  # кол-во файлов, которое нужно сгенерировать.
    local target_dir=$2   # директория, в которой будут созданы файлы.
    # local – создает локальную переменную внутри функции, чтобы она не повлияла на переменные с тем же именем вне функции.

    if [ -d "$target_dir" ]; then   # проверяет, существует ли директория target_dir
    # -d — это флаг, используемый в условных выражениях в Bash для проверки существования директории

        echo "Генерация файлов по 25 Мб для теста: $files_counter шт."
        for i in $(seq 1 "$files_counter"); do   # цикл, который будет выполняться files_counter раз. команда seq создаёт последовательность чисел от 1 до заданного значения.
        # seq 1 "$files_counter" – команда seq генерирует последовательность чисел от 1 до значения files_counter, по одному числу на каждую итерацию цикла.

            dd if=/dev/zero of="$target_dir/file_$i" bs=1M count=25 status=none 
            # dd - data definition - команда для копирования данных и создания файлов определенного размера
            # if=/dev/zero – источник данных, состоящих только из нулей (генерирует пустые байты).
            # of="$target_dir/file_$i" – путь для создания файла, где $target_dir — указанная директория, а file_$i — имя файла, включающее номер текущей итерации ($i), например file_1, file_2 и т.д
            # bs=1M – block size" (размер блока) - размер одного блока данных, равный 1 мегабайту
            # count=25 – количество блоков данных. В итоге файл будет иметь размер 25 мегабайт.
            # status=none – отключает вывод в терминал о ходе выполнения команды dd, делая процесс менее загроможденным.
 
            sleep 0.1  # задержка в 0.1 секунды между созданием каждого файла для изменения времени последнего изменения файла.
        done
    fi
} 




function testcase()  #функция тестирования.
{
    local LOG_DIR=$1  # принимает аргумент LOG_DIR - директория с логами.
    local BACKUP_DIR=$2  # принимает аргумент BACKUP_DIR - директория для бэкапов.
    local THRESHOLD=$3  # принимает аргумент THRESHOLD - порог заполненности раздела в процентах.
    local N=$4  # принимает аргумент N - количество файлов, которые подлежат удалению.
    local FILES_COUNTER=$5  # принимает аргумент FILES_COUNTER - количество файлов, которые будут сгенерированы.
    echo "Начало теста. Порог: $THRESHOLD%, удалению подлежат файлы: $N шт."
    generate_files "$FILES_COUNTER" "$LOG_DIR"   # вызов функции generate_files для генерации файлов в директории логов.
    ./archieve_script.sh "$LOG_DIR" "$BACKUP_DIR" "$THRESHOLD" "$N" 
    # запускает скрипт архивации archieve_script.sh, передавая ему параметры: директорию логов, директорию для архива, порог заполненности и кол-во файлов для удаления.
    rm -rf "$LOG_DIR"/*  # удаляет все файлы в директории логов.
    # rm – это основная команда для удаления файлов или каталогов в Unix-подобных системах, включая Linux.
    # -r – опция, сокращение от "recursive" (рекурсивно). Эта опция указывает команде rm удалять не только файлы, но и папки вместе с их содержимым.
    # -f – опция, сокращение от "force" (форсировать). Она говорит команде rm не спрашивать подтверждение на удаление, даже если файлы защищены от записи
    # * – это символ подстановки (wildcard), означающий "всё" в текущем каталоге
    
    if [ -d "$BACKUP_DIR" ]; then
    # -d – флаг, указывающий на проверку, является ли указанное значение директорией
    
        rm -rf "$BACKUP_DIR"/*   # если директория для бэкапов существует, удаляет все файлы в этой директории.
    # rm – это основная команда для удаления файлов или каталогов в Unix-подобных системах, включая Linux.
    # -r – опция, сокращение от "recursive" (рекурсивно). Эта опция указывает команде rm удалять не только файлы, но и папки вместе с их содержимым.
    # -f – опция, сокращение от "force" (форсировать). Она говорит команде rm не спрашивать подтверждение на удаление, даже если файлы защищены от записи
    # * – это символ подстановки (wildcard), означающий "всё" в текущем каталоге 

    else   # если директория не существует, создаёт новую в домашней директории пользователя и удаляет файлы.
        LAST_DIR=$(basename "$$BACKUP_DIR")
    # basename – команда, которая возвращает последнее имя в пути, отсекая всё остальное.
        BACKUP_DIR="$HOME/$LAST_DIR"
        rm -rf "$BACKUP_DIR"/*
    # rm – это основная команда для удаления файлов или каталогов в Unix-подобных системах, включая Linux.
    # -r – опция, сокращение от "recursive" (рекурсивно). Эта опция указывает команде rm удалять не только файлы, но и папки вместе с их содержимым.
    # -f – опция, сокращение от "force" (форсировать). Она говорит команде rm не спрашивать подтверждение на удаление, даже если файлы защищены от записи
    # * – это символ подстановки (wildcard), означающий "всё" в текущем каталоге 

    fi
    echo "Тест завершён."
}



#тест 1. порог - 50%, удаляем 10 файлов, создаём 30 файлов по 25 мб (750 мб)
testcase "$MOUNT_POINT/log" "$HOME/backup" 50 10 30



#тест 2. порог - 50%, удаляем 10 файлов, создаём 10 файлов по 25 мб (250 мб), 
testcase "$MOUNT_POINT/log" "$HOME/backup" 50 10 10



#тест 3. порог - 50%, удаляем 10 файлов, создаём 30 файлов по 25 мб (250 мб), директория backup_dir не существует
testcase "$MOUNT_POINT/log" "$HOME/backup1" 50 10 30



#тест 4. порог - 50%, удаляем 10 файлов, создаём 30 файлов по 25 мб (250 мб), директория log_dir не существует
testcase "$MOUNT_POINT/log1" "$HOME/backup" 50 10 30



# Размонтируем виртуальный диск
sudo umount "$MOUNT_POINT"



# Удаляем точку монтирования
rmdir "$MOUNT_POINT"



# Удаляем файл виртуального диска
rm -f "$VIRTUAL_DISK"


echo "Виртуальный диск размонтирован, папка удалена, файл диска удалён."


# Что происходит, по пунктам:
# 1) Создание виртуального диска: объявлены переменные для виртуального диска и точки монтирования. VIRTUAL_DISK - путь к файлу виртуального диска, 
# MOUNT_POINT - путь, куда виртуальный диск будет монтироваться.
# 2) Создание файла виртуального диска размером 1Гб: команда dd создаёт файл размером 1Гб и заполняет его нулями.
# 3) Создание файловой системы ext4 на виртуальном диске.
# 4) Создание папки для монтирования, если она не существует.
# 5) Монтирование виртуального диска в точку монтирования.
# 6) Изменение прав доступа на 777 для точки монтирования.
# 7) Создание папки log в смонтированном разделе.
# 8) Создание папки backup в домашней директории.
# 9) Вывод сообщения о завершении операций с монтированием.
# 10) Функция генерации файлов generate_files().
# 11) Функция тестирования testcase().
# 12) Тестовые случаи.
# 13) Размонтирование виртуального диска.
# 14) Удаление точки монтирования.
# 15) Удаление файла виртуального диска.
# 16) Вывод сообщения о завершении работы.
# Итог: скрипт автоматизирует процесс создания виртуального диска, монтирования, генерации файлов, архивации и удаления файлов в зависимости от порога 
# использования диска. Виртуальный диск удаляется по завершении тестов.

