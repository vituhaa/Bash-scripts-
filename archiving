#!/bin/bash

# 1: входные параметры.
LOG_DIR=$1 #присваивается значение первого аргумента командной строки,который передаётся при вызове скрипта. это директория,в кот хранятся файлы
BACKUP_DIR=$2 #переменной присваивается значение 2-го аргумента командной строки. это директория, в которую будут сохраняться файлы
THRESHOLD=$3 #присваивается значение 3-го аргумента. это порог заполненности диска в %, при достижении которого скрипт начнёт архивировать файлы
N=$4 # присваивается значение 4-го аргумента, это кол-во старых файлов, кот будут архивированы.





# 2: проверка существования директории, переданной в LOG_DIR.
if [ ! -d "$LOG_DIR" ]; then     # -d  - проверяет, существует ли указанная директория
            echo "Ошибка: директория $1 не существует."
            exit 1     # завершение скрипта с кодом выхода 1, что указывает на ошибку.
    fi




# 3: узнаем размер раздела, на котором находится LOG_DIR, и его использование.
USAGE=$(df "$LOG_DIR" | awk 'NR==2 {print $5}' | sed 's/%//')
# df "$LOG_DIR"   - df выводит информацию о файловой системе, на которой находится директория. "$LOG_DIR" указывает,что нас интересует использование диска, на кот
# расположена эта директория. df  выводит табличку с данными, где пятый столбец - "Use%", нам он и нужен.
# |  - pipe: позволяет передать вывод предыдущей команды на вход следующей.
# awk 'NR==2 {print $5}'  - awk - язык обработки текстов. здесь NR==2 указывает,что мы берём вторую строку (поскольку первая строка - это заголовки)
# {print $5}  - выводит пятый столбец, который содержит информацию о заполненности в процентах.
# sed 's/%//'  - sed - это потоковый редактор. здесь команда s/%// удаляет символ % из полученного значения заполненности. % между первым и вторым слэшем - это то,
# ЧТО нужно за менить, пустое место между вторым и третьим - НА что нужно заменить.





# 4: проверка заполненности раздела.
if [ "$USAGE" -ge "$THRESHOLD" ]; then # проверка: если использование диска (USAGE) в директории LOG_DIR >= порогу THRESHOLD, то запускается процесс архивирования
  # -ge  - greater or equal - сравнение двух чисел
  # 5: сообщение о необходимости очистки.
  echo "Папка $LOG_DIR заполнена на $USAGE%, порог $THRESHOLD% достигнут. Требуется очистка."

  # 6: получаем список N самых старых файлов.
  mapfile -t FILES_TO_ARCHIVE < <(find "$LOG_DIR" -type f -printf "%T@ %p\n" | sort -n | head -n "$N" | awk '{print $2}')
  # mapfile -t FILES_TO_ARCHIVE  - сохраняет результаты команды в массив FILES_TO_ARCHIVE. команда mapfile используется для чтения строк из входного потока и
  # сохранения их в массив.  -t  - опция, которая указывает, что нужно удалить символы новой строки (\n) в конце каждой строки, чтобы каждая строка была 
  # записана в массив без лишних переводов строки.
  # Конструкция < <(...) в Bash называется процесс-замещением (process substitution). Это специальный механизм, который позволяет передавать вывод одной 
  # команды (внутри (...)) в другую команду как входной поток. Таким образом, ты можешь использовать результат работы команды как файл или как ввод для другой 
  # команды, без необходимости временно сохранять его в файл.
  # find "$LOG_DIR" -type f -printf "%T@ %p\n"  - команда find ищет все файлы в указанной директории ("$LOG_DIR").
  # опция -type f указывает на то, что нужно искать только файлы.
  # формат вывода задаётся через -printf:   %T@ - время последней модификации файла в формате UNIX timestamp (кол-во секунд с 1 января 1970 года)
  # %p - полный путь к файлу
  # sort -n  - сортирует файлы по времени от самых старых к новым (-n используется для сортировки по числовому значению, а не по алфавиту).
  # head -n "$N"  - отбирает только первые N строк (-n используется для вывода указанного кол-ва строк), где N - это кол-во файлов, которые нужно архивировать
  # awk '{print $2}'  - выбирает второй столбец из вывода (полный путь к файлам)
  




  # 7: проверка наличия файлов для архивации.
  if [ ${#FILES_TO_ARCHIVE[@]} -eq 0 ]; then  # проверка: если массив FILES_TO_ARCHIVE пустой (нет файлов для архивирования), то выводится сообщение
  # FILES_TO_ARCHIVE[@] - доступ ко всем элементам массива. # перед именем массива - возвращает длину массива,т.е. кол-во эл-ов в массиве.
    echo "Нет файлов для архивации."
    exit 0  # в этом случае скрипт завершает работу (код 0 - успешное выполнение)
  fi





  # 8: вывод списка файлов для архивации.
  for file in "${FILES_TO_ARCHIVE[@]}"; do  # начало цикла по каждому файлу из массива FILES_TO_ARCHIVE. каждый файл сохраняется в переменную file
                                            # @ используется для того, чтобы получить все элементы массива одновременно
        echo "Файл $file подлежит архивации."  # для каждого файла выводится сообщение о том,что он будет архивирован
    done




  # 9: проверка существования директории для архива.
  if [ ! -d "$BACKUP_DIR" ]; then  # проверка: существует ли директория для архивов BACKUP_DIR. если она не существует, то её нужно создать
    LAST_DIR=$(basename "$BACKUP_DIR")  # извлечение имени последней директории из полного пути BACKUP_DIR. например, для пути /home/user/backup, 
                                        # basename вернёт backup.
                                        # basename - это команда, кот. извлекает имя файла или директории из полного пути, удаляя все каталоги.
    echo "Создание директории $HOME/$LAST_DIR..."  # соо о создании директории в домашней директории пользователя
    mkdir -p "$HOME/$LAST_DIR"  # создание директории LAST_DIR в домашней директории пользователя. mkdir -p создаёт директорию,если её не существует
                                # -p  создаёт все недостающие родительские директории, если их нет. (если у нас есть только backup из /home/user/backup, то
                                # /home/user доделаются сами.
    BACKUP_DIR="$HOME/$LAST_DIR"  # переопределение переменной BACKUP_DIR, чтобы указать новую директорию
  fi





  # 10: Создаем архив с точной датой и временем
  DATE=$(date +"%Y-%m-%d_%H-%M-%S")  # получение текущей даты в формате ГГГГ-ММ-ДД-ЧЧ-ММ-СС, чтобы добавить к имени архива уникальный временной маркер
  echo "Архивация..."
  tar -czf "$BACKUP_DIR/archive_$DATE.tar.gz" -C "$LOG_DIR" $FILES_TO_ARCHIVE 
  # tar -czf  - создаём архив в формате .tar.gz 
  # -czf в bash-скрипте — это ключ к команде tar, который означает «сохранить по указанному пути». 
  # Например, с его помощью создают скрипты резервного копирования, используя ключи 
  # -c (создать), -z (заархивировать средствами пакета gzip) и -f (сохранить по указанному пути "$BACKUP_DIR/archive_$DATE.tar.gz"). 
  # "$BACKUP_DIR/archive_$DATE.tar.gz" - имя архива, включая текущую дату
  # -C "$LOG_DIR"  - переходим в директорию с логами перед архивацией (-C - флаг в команде tar означает смену текущей директории)
  # $FILES_TO_ARCHIVE  - указываем файлы для архивации 
  echo "Архивация завершена. Удаление файлов..."




  # 11: удаление архивированных файлов.
  for FILE in "${FILES_TO_ARCHIVE[@]}"; do  # начинаем цикл по каждому архивированному файлу
    BASE_FILE=$(basename "$FILE")  # Получаем только имя файла без полного пути 
    rm "$LOG_DIR/$BASE_FILE"        # Удаляем файл из директории логов с помощью команды rm ("$LOG_DIR/$BASE_FILE": полное имя файла, которое строится путём 
                                    # объединения пути директории ($LOG_DIR) и имени файла ($BASE_FILE).
  done



  # 12: завершение.
  echo "Удаление файлов завершено."




# 13: если порог не достигнут.
else
  echo "Папка $LOG_DIR еще не достигла порога $THRESHOLD%."
fi


# Что делает скрипт, поэтапно:
# 1) принимает на вход 4 аргумента (LOG_DIR, BACKUP_DIR, THRESHOLD, N)
# 2) проверяет существование директории логов : проверяется,существует ли директория, переденная в кач-ве первого аргумента (LOG_DIR). 
# Если директория не существует, выводится сообщение об ошибке и скрипт завершает работу.
# 3) Узнаём процент заполнения раздела : с помощью df определяется процент заполненности раздела, на котором находится директория LOG_DIR, извлекается
# пятый столбец (процент использования диска) из второй строки вывода df, убирается символ процента из строки, чтобы получить числое числовое значение.
# 4) Проверка заполненности раздела : если заполненность раздела (значение USAGE) превышает или равна порогу (THRESHOLD), начинается процесс архивации
# и удаления старых файлов.
# 5) Сообщение о необходимости очистки : выводится сообщение, что папка достигла порога заполненности и требуется очистка. 
# 6) Поиск самых старых файлов (ф-я mapfile).
# 7) Проверка наличия файлов для архивации: если в массиве FILES_TO_ARCHIVE нет файлов (его длина равна 0), выводится сообщение, что нет файлов для архивации,
# и скрипт завершает работу.
# 8) Вывод списка файлов для архивации: для каждого файла из массива FILES_TO_ARCHIVE выводится сообщение, что он подлежит архивации.
# 9) Проверка существования директории для архива: если директория для архива не существует, она создаётся. Название директории извлекается из переменной
# BACKUP_DIR, и новая директория создаётся в домашней директории пользователя ($HOME).
# 10) Создание архива: Создается архив с именем archive_YYYY-MM-DD_HH-MM-SS.tar.gz в директории для архивов (BACKUP_DIR). Архив включает в себя файлы 
# из массива FILES_TO_ARCHIVE. После создания архива выводится сообщение, что архивация завершена, и начинается удаление файлов.
# 11) Удаление архивированных файлов: для каждого файла из массива FILES_TO_ARCHIVE выполняетя команда rm, которая удаляет файл из директории логов.
# 12) Завершение: выводится сообщение, что все архивированные файлы были успешно удалены.
# 13) Если порог не достигнут: если процент заполненности раздела меньше порога, то выводится сообщение, что архивирование не требуется.
