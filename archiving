#!/bin/bash

# путь к папке, путь архивации, порог заполнения и число файлов, подлежащих архивации
LOG_DIR=$1 #присваивается значение первого аргумента командной строки,который передаётся при вызове скрипта. это директория,в кот хранятся лог-файлы
BACKUP_DIR=$2 #переменной присваивается значение 2-го аргумента командной строки. это директория, в которую будут сохраняться файлы
THRESHOLD=$3 #присваивается значение 3-го аргумента. это порог заполненности диска в %, при достижении которого скрипт начнёт архивировать файлы
N=$4 # присваивается значение 4-го аргумента, это кол-во старых файлов, кот будут архивированы.





# проверка существования директории, переданной в LOG_DIR
if [ ! -d "$LOG_DIR" ]; then     # -d  - проверяет, является ли указанное имя директорией
            echo "Ошибка: директория $1 не существует."
            exit 1     # завершение скрипта с кодом выхода 1, что указывает на ошибку.
    fi




# узнаем размер раздела, на котором находится LOG_DIR, и его использование
USAGE=$(df "$LOG_DIR" | awk 'NR==2 {print $5}' | sed 's/%//')
# df "$LOG_DIR"   - df выводит информацию о файловой системе, на которой находится директория. "$LOG_DIR" указывает,что нас интересует использование диска, на кот
# расположена эта директория.
# |  - pipe: позволяет передать вывод предыдущей команды на вход следующей.
# awk 'NR==2 {print $5}'  - awk - язык обработки текстов. здесь NR==2 указывает,что мы берём вторую строку (поскольку первая строка - это заголовки)
# {print $5}  - выводит пятый столбец, который содержит информацию о заполненности в процентах.
# sed 's/%//'  - sed - это потоковый редактор. здесь команда s/%// удаляет символ % из полученного значения заполненности.





# проверка заполненности раздела
if [ "$USAGE" -ge "$THRESHOLD" ]; then # проверка: если использование диска (USAGE) в директории LOG_DIR >= порогу THRESHOLD, то запускается процесс архивирования
  # -ge  - greater or equal - сравнение двух чисел
  echo "Папка $LOG_DIR заполнена на $USAGE%, порог $THRESHOLD% достигнут. Требуется очистка."

  # получаем список N самых старых файлов
  mapfile -t FILES_TO_ARCHIVE < <(find "$LOG_DIR" -type f -printf "%T@ %p\n" | sort -n | head -n "$N" | awk '{print $2}')
  # find "$LOG_DIR" -type f -printf "%T@ %p\n"  - команда find ищет все файлы в указанной директории ("$LOG_DIR").
  # опция -type f указывает на то, что нужно искать только файлы.
  # формат вывода задаётся через -printf:   %T@ - время последней модификации файла в формате UNIX timestamp (кол-во секунд с 1 января 1970 года)
  # %p - полный путь к файлу
  # sort -n  - сортирует файлы по времени от самых старых к новым
  # head -n "$N"  - отбирает только первые N строк, где N - это кол-во файлов, которые нужно архивировать
  # awk '{print $2}'  - выбирает второй столбец из вывода (полный путь к файлам)
  # mapfile -t FILES_TO_ARCHIVE  - сохраняет результаты команды в массив FILES_TO_ARCHIVE. команда mapfile используется для чтения строк из входного потока и
  # сохранения их в массив.  -t  - опция, которая указывает, что нужно удалить символы новой строки (\n) в конце каждой строки, чтобы каждая строка была 
  # записана в массив без лишних переводов строки.





  if [ ${#FILES_TO_ARCHIVE[@]} -eq 0 ]; then  # проверка: если массив FILES_TO_ARCHIVE пустой (нет файлов для архивирования), то выводится сообщение
    echo "Нет файлов для архивации."
    exit 0  # в этом случае скрипт завершает работу (код 0 - успешное выполнение)
  fi





  # выведем его на экран
  for file in "${FILES_TO_ARCHIVE[@]}"; do  # начало цикла по каждому файлу из массива FILES_TO_ARCHIVE. каждый файл сохраняется в переменную file
                                            # @ используется для того, чтобы получить все элементы массива одновременно
        echo "Файл $file подлежит архивации."  # для каждого файла выводится сообщение о том,что он будет архивирован
    done





  if [ ! -d "$BACKUP_DIR" ]; then  # проверка: существует ли директория для архивов BACKUP_DIR. если она не существует, то её нужно создать
    LAST_DIR=$(basename "$BACKUP_DIR")  # извлечение имени последней директории из полного пути BACKUP_DIR. например, для пути /home/user/backup, 
                                        # basename вернёт backup 
    echo "Создание директории $HOME/$LAST_DIR..."  # соо о создании директории в домашней директории пользователя
    mkdir -p "$HOME/$LAST_DIR"  # создание директории LAST_DIR в домашней директории пользователя. mkdir -p создаёт директорию,если её не существует
                                # -p  создаёт все недостающие родительские директории, если их нет. 
    BACKUP_DIR="$HOME/$LAST_DIR"  # переопределение переменной BACKUP_DIR, чтобы указать новую директорию
  fi





  # Создаем архив с точной датой и временем
  DATE=$(date +"%Y-%m-%d_%H-%M-%S")  # получение текущей даты в формате ГГГГ-ММ-ДД-ЧЧ-ММ-СС, чтобы добавить к имени архива уникальный временной маркер
  echo "Архивация..."
  tar -czf "$BACKUP_DIR/archive_$DATE.tar.gz" -C "$LOG_DIR" $FILES_TO_ARCHIVE 
  # tar -czf  - создаём архив в формате .tar.gz 
  # -czf в bash-скрипте — это ключ к команде tar, который означает «сохранить по указанному пути». 
  # Например, с его помощью создают скрипты резервного копирования, используя ключи 
  # -c (создать), -z (заархивировать средствами пакета gzip) и -f (сохранить по указанному пути). 
  # "$BACKUP_DIR/archive_$DATE.tar.gz" - имя архива, включая текущую дату
  # -C "$LOG_DIR"  - переходим в директорию с логами перед архивацией (-C - флаг в команде tar означает смену текущей директории)
  # $FILES_TO_ARCHIVE  - указываем файлы для архивации 
  echo "Архивация завершена. Удаление файлов..."





  for FILE in "${FILES_TO_ARCHIVE[@]}"; do  # начинаем цикл по каждому архивированному файлу
    BASE_FILE=$(basename "$FILE")  # Получаем только имя файла без полного пути 
    rm "$LOG_DIR/$BASE_FILE"        # Удаляем файл из директории логов с помощью команды rm
  done




  echo "Удаление файлов завершено."





else
  echo "Папка $LOG_DIR еще не достигла порога $THRESHOLD%."
fi
